### Создание самописного (custom) Spring Boot стартера.

Из нашего основного приложения можно выделить некие блоки кода, или функционал, которые не обязаны быть зашиты в общую 
структуру сервиса. Более того этот функционал может быть самостоятельным и самое главное многократно переиспользуемым. 
Фактически, наш будущий стартер (будущие стартеры) это вынесенная во вне, не ключевая, и часто сквозная, логика основного 
приложения. 

На протяжении последних "пары шагов" у нас стояла задача проводит расчет времени работы выбранных методов. Мы делали это 
используя механизмы AOP, сами аспекты были связаны с приложением. Однако, похожая задача может возникнуть в любом Spring 
Boot приложении, т.е. логично было бы вынести такой функционал в отдельный модуль (стартер) и затем переиспользовать его 
везде где необходимо. 

И так, создадим наш кастомный стартер, который будет рассчитывать время работы методов аннотированных, как @Measurable 
[см. пример прошлого проекта](https://github.com/JcoderPaul/Evolution_app_development/blob/master/StepFour/src/main/java/me/oldboy/services/PlaceService.java).

Фактически, нам надо сделать приложение содержащее набор bean-s (компонентов), зависимостей с возможностью их конфигурирования,
либо вручную, либо автоматически (авто-конфигурация). Данное приложение, с конкретным набором bean-s, за счет их функционала 
(назначения, логики) и конфигурации будет решать конкретную бизнес задачу. 

В нашем случае таковых будет две - по стартеру на задачу - расчет времени работы выбранного метода и аудит действий пользователя.
При этом, такое приложение может быть подключено в качестве зависимости к любому другому приложению (сервису). Алгоритм 
пошаговый создания стартеров однотипен - опишем его на примере нашего time-logger-a.

И так, поехали! 

На данном этапе сделаем просто - создадим отдельный модуль-стартер (без выноса в отдельное приложение), будем действовать,
как описано в ["сборнике статей"](https://github.com/JcoderPaul/Spring_Framework_Lessons/tree/master/Spring_part_25/DOC) по данному вопросу:
- Шаг 1. - внутри текущего проекта создаем отдельный модуль - именуем сообразно "конвенции";
- Шаг 2. - среда разработки формирует автоматически необходимый минимальный набор папок и файлов;
- Шаг 3. - в файл настроек build.gradle добавляем необходимый минимум зависимостей, в том числе наиболее важные для конфигурирования:

            annotationProcessor 'org.springframework.boot:spring-boot-autoconfigure-processor'
            annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'

- Шаг 4. - делаем наш стартер авто-конфигурируемым - создаем пакет config для хранения файлов конфигурации и свойств;
- Шаг 5. - в отдельный пакет выделяем логику отвечающую за замер времени работы аннотированных методов - measurer (фактически это структура аспектов, наши pointcuts и advices, ранее бывшие неотъемлемыми компонентами моно-модульного приложения), это и есть "сам стартер";
- Шаг 6. - создаем файл, который будет сканироваться Spring приложением, применившем наш стартер в качестве зависимости и его bean-s (компоненты стартера) "прогрузятся" в контекст приложения "как родные"; 

Стоит отметить, что в зависимости от версии Spring Boot-a файл описывающий метаданные авто-конфигурации несколько отличаются:
- до версии Spring Boot 2.7 (ранние) - META-INF/spring.factories;
- более поздние версии, т.е. выше Spring Boot 2.7 - META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports;

Однако содержимое этих файлов не сильно отличается:

            org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
            me.oldboy.logger.config.LoggerAutoConfiguration

А теперь, тонкий момент - наш MethodSpeedCalcAspect.java, помеченный ранее (на ["четвертом шаге"](https://github.com/JcoderPaul/Evolution_app_development/blob/master/StepFour/src/main/java/me/oldboy/aspects/MethodSpeedCalcAspect.java)) как компонент, теперь
должен создаваться как bean в файле авто-конфигурации - LoggerAutoConfiguration.java текущего модуля.

- Шаг 7. - прописываем создание всех необходимых bean-s текущего стартера в файле авто-конфигурации.
- Шаг 8. - подключаем созданный стартер в основное приложение через build.gradle:

            implementation project(':time-logger-spring-boot-starter')

- Шаг 9. - прописываем настройку логгер-стартера в файле свойств основного проекта application.yml:

            app:
              time:
                logger:
                  enabled: true

- Шаг 10. - в основном приложении аннотируем каждый метод слоя сервисов, как @Measurable и запускаем приложение. 

Необходимо обратить внимание на то, что среда разработки сама прописывает наши custom стартеры в настройки основного проекта
settings.gradle, в процессе стартовой инициализации:

            include 'time-logger-spring-boot-starter'
            include 'audit-writer-spring-boot-starter'

Теперь, при обращении к ключевым endpoint-ам через Postman мы можем увидеть в консоли и лог файлах информацию, возвращаемую
логгером - время работы сервис метода задействованного при обращении к слою контроллеров. Если кратко, то так выглядит 
процесс создания и применения простого Spring Boot стартера. 

Теперь коснемся некоторых моментов чуть подробнее.
________________________________________________________________________________________________________________________
### Описание конфигурации стартера, аннотаций и логики происходящего.

Хотя наш текущий стартер визуально прост, содержит всего-то пяток небольших файлов, все же стоит изучить происходящее 
еще ближе. Повторимся, у нас небольшое самостоятельное приложение со своим набором bean-ов и необходимых зависимостей,
которое должно выполнять некую стандартную функцию (набор функций). Т.е. у нас есть некий рабочий код, который мы хотим
задействовать в другом приложении, что бы не писать его "с нуля". Так же у нас должна быть возможность управлять 
настройками этого приложения, тем или иным способом, лучше через набор параметров и желательно "автоматически". 

Посему любой стартер (любое приложение), условно, можно разбить на два блока - код стартера, конфигурация стартера.
Начнем с кода (логики работы) стартера. У нас он разнесен по двум пакетам:
- annotation - тут находится наша аннотация, которой нужно помечать методы требующие измерения времени их выполнения ([см. предыдущий проект](https://github.com/JcoderPaul/Evolution_app_development/tree/master/StepFour/src/main/java/me/oldboy/annotations));
- measurer - пакет с нашим "измерителем скорости", фактически, это старые добрые pointcut и advice, разве что без пометки компонент ([см. предыдущий проект](https://github.com/JcoderPaul/Evolution_app_development/tree/master/StepFour/src/main/java/me/oldboy/aspects))

Т.е. мы просто перенесли старый код в "новую обертку". Самое интересное - это как подключить его к новому проекту и 
заставить работать, как раньше. Для этого у нас есть пакеты - config и META-INF. Как ранее упоминалось в пакете META-INF
должен находиться один из двух типов файлов, указывающих на файл авто-конфигурации, "обычно" в папке config. Почему обычно,
просто мы можем сделать стартер со всеми необходимыми bean-s и зависимостями, но конфигурировать их полностью вручную.
________________________________________________________________________________________________________________________

В папке config у нас есть LoggerAutoConfiguration.java, с него и начнем изучение. 

Применяемые аннотации:
- **@Configuration** – аннотация на уровне класса (с ней мы знакомы, но повторим), указывающая на то, что объект является 
источником bean-s. Классы, аннотированные, как @Configuration, объявляют bean-s через методы, аннотированные - @Bean. 
Вызовы методов @Bean для классов @Configuration также могут быть использованы для определения межбиновых зависимостей, 
т.е. когда одни bean-ы зависят от других и создаются, например, внутри текущей конфигурации. Spring при старте ищет 
классы с аннотацией @Configuration, вызывает все методы, аннотированные @Bean, сохраняет все возвращаемые значения в 
контекст приложения и делает их доступными для внедрения (injection).

Т.е. наш файл LoggerAutoConfiguration.java содержит будущие компоненты для приложения, которое использует наш стартер. 
- **@EnableConfigurationProperties** - эта аннотация указывает Spring, что нужно сканировать классы, помеченные 
@ConfigurationProperties, и создавать для них bean-ы, которые будут заполнены значениями из конфигурационных файлов 
(*.properties). Без @EnableConfigurationProperties Spring не будет автоматически обрабатывать такие классы, даже если 
они помечены @ConfigurationProperties.

Данная аннотация упрощает работу с конфигурацией. Позволяет разработчикам определять классы с полями, которые автоматически 
"сопоставляются" (mapping) на свойства из конфигурационных файлов, делая код более типобезопасным и удобным для работы.

Делаем конфигурирование гибким, т.к. поддерживает настройку приложения через внешние источники (например, файлы свойств, 
переменные окружения, аргументы командной строки), обеспечивая централизованное управление конфигурацией.

Аннотация @EnableConfigurationProperties обычно применяется на уровне конфигурационного класса (например, класса, 
помеченного @Configuration, как наш LoggerAutoConfiguration.java). Мы можем указать конкретные классы конфигурационных 
свойств, которые должны быть зарегистрированы, используя атрибут value (мы указали класс использующий внешний источник 
конфигурации или наш файл конфигурационных свойств):

      @EnableConfigurationProperties(LoggerProperties.class)

- **@ConditionalOnClass** — мощный инструмент для условной конфигурации, который делает приложения более гибкими и 
модульными, позволяя Spring Boot автоматически адаптироваться к наличию или отсутствию определённых библиотек в проекте.
@ConditionalOnClass применяется на уровне класса или метода (в конфигурационных классах с аннотацией @Configuration) и 
указывает, что bean будет создан только при наличии определённого класса или классов в classpath. Это полезно для:
  - Условной загрузки bean-ов в зависимости от доступности библиотек.
  - Создания модульных приложений, где определённые компоненты подключаются только при наличии необходимых зависимостей.
  - Авто-конфигурации в Spring Boot, где многие конфигурации зависят от присутствия определённых библиотек.

В нашем случае LoggerAutoConfiguration.java будет применена только если в classpath есть класс LoggerProperties.class.
Многие авто-конфигурации в Spring Boot используют @ConditionalOnClass для проверки наличия библиотек. Например, конфигурация 
для работы с базой данных включается только при наличии JDBC или JPA в classpath.

- **@ConditionalOnProperty** - эта аннотация используется для условной регистрации bean-a или конфигурации в контексте 
приложения на основе значения свойства в конфигурации (например, в application.properties или application.yml). Она 
позволяет включать или отключать определённые bean-ы или конфигурации в зависимости от того, присутствует ли свойство, 
и соответствует ли его значение заданным условиям.

**Основные атрибуты @ConditionalOnProperty**:
- **value или name**: Указывает имя свойства, которое проверяется в конфигурации.
- **havingValue**: Указывает ожидаемое значение свойства. Если свойство имеет это значение, условие считается выполненным, и бин регистрируется.
- **matchIfMissing**: Определяет, что делать, если свойство отсутствует. Если matchIfMissing = true, и свойства нет, условие считается выполненным. По умолчанию false.
- **prefix**: Позволяет указать префикс для свойства, чтобы группировать связанные свойства.

В нашем случаем LoggerAutoConfiguration.java аннотирован, как:

      @ConditionalOnProperty(prefix = "app.time.logger", name = "enabled", havingValue = "true")

Т.е. наша конфигурация будет применена, только если в application.properties (*.yml) есть свойство "enabled", с префиксом
"app.time.logger" и его значение установлено в true. В остальных случаях функционал нашего стартера не будет применен к
основному коду приложения. Причем само свойство "enabled" определено в LoggerProperties.
________________________________________________________________________________________________________________________
Наш LoggerProperties.java содержит одно поле "enabled" и аннотирован @ConfigurationProperties.  

- **@ConfigurationProperties** - эта аннотация используется для автоматического связывания (binding) свойств из внешних 
источников конфигурации (например, файлов application.properties, или в нашем случае это application.yml) с полями 
Java-объекта (в нашем случае это поле enabled). Это упрощает работу с конфигурационными данными, позволяя сопоставлять 
(mapping) их на структурированный объект.

**Основное назначение в инфраструктуре Spring:**
- Сопоставление свойств: Позволяет маппить свойства из конфигурационных файлов (или других источников, таких как переменные окружения) на поля класса.
- Упрощение конфигурации: Вместо ручного чтения свойств через @Value или Environment, можно использовать объект с аннотированными полями, что делает код более читаемым и типобезопасным.
- Поддержка вложенных свойств: Позволяет работать с иерархическими конфигурациями, например, маппить сложные структуры из YAML/JSON.
- Валидация: Поддерживает интеграцию с JSR-303/349 (валидация через аннотации, такие как @NotNull, @Size и т.д.).
- Динамическое обновление: В сочетании с @RefreshScope позволяет обновлять значения свойств без перезапуска приложения.

**Как это работает:**
- Аннотация @ConfigurationProperties(prefix = "app.time.logger") указывает, что свойства с префиксом "app.time.logger" будут привязаны к полям текущего класса (у нас это поле "enabled" см. application.yml).
- Поле (поля) класса (у нас enabled) автоматически заполняется значением из внешней конфигурации.
- Для работы аннотации класс должен быть зарегистрирован как Spring Bean (например, через @Component или @Bean, в нашем случае он используется в аннотациях авто-конфигуратора).
- Необходимо включить поддержку @ConfigurationProperties в приложении, добавив зависимость spring-boot-configuration-processor (для автогенерации метаданных), см. build.gradle нашего стартера.

**Когда использовать:**
- Когда нужно централизованно управлять конфигурацией приложения.
- Для работы с большими или иерархическими конфигурациями.
- Когда требуется типобезопасность и валидация конфигурационных данных.

**Особенности применения (наглядно отображен в нашем случае):**
- Для активации обработки @ConfigurationProperties в Spring Boot добавьте зависимость: spring-boot-configuration-processor.
- Класс должен иметь геттеры и сеттеры для корректного связывания.
- Можно комбинировать с @EnableConfigurationProperties, если класс не помечен @Component.
________________________________________________________________________________________________________________________

Фактически данного описания достаточно, для понимания работы нашего стартера. Еще немного материала по вопросу:
- см. [старый "сборник статей" по текущему вопросу](https://github.com/JcoderPaul/Spring_Framework_Lessons/tree/master/Spring_part_25/DOC);
- [Как создать custom стартер - быстро и кратко](https://github.com/JcoderPaul/Evolution_app_development/blob/master/StepFive/DOC/CustomSpringStarterGuide.md);
- [Аннотации применяемые при создании стартеров](https://github.com/JcoderPaul/Evolution_app_development/blob/master/StepFive/DOC/ConditionAnnotationFamily.md);