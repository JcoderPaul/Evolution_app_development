*** Когда использовать doAnswer и thenReturn ***
_____________________________________________________________________________________________________________________________________________________________
*** Быстрый ответ ***
Если требуется возвратить фиксированное значение, лучше всего использовать thenReturn(), оно обеспечивает четкую подстановку:

*************************************************************************************************************************************************************

when(mock.someMethod()).thenReturn(value);

*************************************************************************************************************************************************************

Когда необходимо добавить логику в ответ, выбирайте doAnswer():

*************************************************************************************************************************************************************

doAnswer(invocation -> "ответ основан на " + invocation.getArgument(0))
    .when(mock).someMethod(any());

*************************************************************************************************************************************************************

_____________________________________________________________________________________________________________________________________________________________
*** Искусство правильного выбора метода подстановки ***

Если нужно статическое значение — выбирайте thenReturn. Метод thenReturn() — надежный спутник для фиксированной подстановки — 
он всецело обеспечит возврат того же результата:

*************************************************************************************************************************************************************

when(mock.myMethod()).thenReturn(myFixedValue);

*************************************************************************************************************************************************************

Если метод вызывается в тесте множество раз, thenReturn() позволяет установить цепочку ответов на последующие вызовы:

*************************************************************************************************************************************************************

when(mock.myMethod()).thenReturn(firstValue, secondValue, thirdValue);

*************************************************************************************************************************************************************

Для динамичных возвращаемых значений лучше выбрать doAnswer. Метод doAnswer() идеально справляется, когда необходим динамический 
ответ. С ним подстановка способна формироваться на основе предложенных (переданных) аргументов:

*************************************************************************************************************************************************************

doAnswer(invocation -> {
    Integer input = invocation.getArgument(0);
    return input * 2; // Создаем ответ
}).when(mock).myMethod(anyInt());

*************************************************************************************************************************************************************

Метод doAnswer() также позволяет осуществлять дополнительные операции при вызове подмененного метода, например, изменять 
состояние или проверять аргументы.

_____________________________________________________________________________________________________________________________________________________________
*** Для методов с возратом void также подойдет doAnswer ***

При использовании методов возвращающих void, применение doAnswer() может воздействовать на методы, изменяющие состояние или 
генерирующие побочные эффекты, как в процессе строительства чего либо по чертежу:

*************************************************************************************************************************************************************

doAnswer(invocation -> {
    System.out.println("Метод вызван с аргументами: " + Arrays.toString(invocation.getArguments()));
    return null; // Возвращаем null для методов void
}).when(mock).voidMethod(any());

*************************************************************************************************************************************************************

*** Ненавязчивое наблюдение с помощью doAnswer ***

Хотите наблюдать за объектами без активизации их реального поведения? Применение (вызов) doAnswer() обеспечивает безопасную 
подмену методов, идеальную для тестов:

*************************************************************************************************************************************************************

doAnswer(invocation -> "значение-заглушка").when(spy).myRealMethod();

*************************************************************************************************************************************************************

_____________________________________________________________________________________________________________________________________________________________
*** Альтернатива в виде doReturn ***

doReturn() — это простой аналог thenReturn(), который стоит использовать, чтобы избежать выполнения логики реального метода:

*************************************************************************************************************************************************************

doReturn("значение-заглушка").when(spy).myRealMethod();

*************************************************************************************************************************************************************

*** Различия между методами doAnswer и thenReturn ***

Основные различия между методами doAnswer и thenReturn:

- thenReturn - Простые задачи. Фиксированный ответ (Это как заказать стандартный бургер: без неожиданностей, ровно как и ожидали);

	when(mock.someMethod()).thenReturn("фиксированный ответ");

- doAnswer - Сложные задачи. Динамические ответы (Это как создать собственный рецепт суши-ролла: творческий процесс с простором для импровизации);

	when(mock.someMethod()).doAnswer(invocation -> {
	    Object arg0 = invocation.getArgument(0);
	    return "ответ создан на основе " + arg0; 
	});

_____________________________________________________________________________________________________________________________________________________________
*** Немного практических примеров ***

*** Имитация исключений при помощи doAnswer ***
doAnswer() позволяет смоделировать поведение кода при возникновении исключений:

*************************************************************************************************************************************************************

doAnswer(invocation -> {
    if ("bad".equals(invocation.getArgument(0))) {
        throw new IllegalArgumentException("Пожалуйста, держитесь подальше от неприятностей!");
    }
    return "а вот и ответ";
}).when(mock).someMethod(anyString());

*************************************************************************************************************************************************************

Имитация временных задержек, при необходимости смоделировать замедленную работу или временные задержки - doAnswer() выполняет роль "машины времени":

*************************************************************************************************************************************************************

doAnswer(invocation -> {
    Thread.sleep(1000L); // Добавляем задержку для эффекта 
    return "Приветствие из будущего!";
}).when(mock).someMethod();

*************************************************************************************************************************************************************

Сложная логика в возвращаемых значениях. Когда требуются дополнительные вычисления или результат зависит от внешних условий, doAnswer() дает 
простор для творчества:

*************************************************************************************************************************************************************

doAnswer(invocation -> {
    if (someExternalCondition) {
        return "состояние достигнуто";
    }
    return "стандартный ответ";
}).when(mock).someMethod();

*************************************************************************************************************************************************************